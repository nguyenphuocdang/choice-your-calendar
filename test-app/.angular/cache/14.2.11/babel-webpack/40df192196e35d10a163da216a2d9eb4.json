{"ast":null,"code":"/**\n * @internal\n */\nconst NULL = 0;\n/**\n * @internal\n */\n\nconst LF = 10;\n/**\n * @internal\n */\n\nconst CR = 13;\n/**\n * @internal\n */\n\nconst COLON = 58;\n/**\n * This is an evented, rec descent parser.\n * A stream of Octets can be passed and whenever it recognizes\n * a complete Frame or an incoming ping it will invoke the registered callbacks.\n *\n * All incoming Octets are fed into _onByte function.\n * Depending on current state the _onByte function keeps changing.\n * Depending on the state it keeps accumulating into _token and _results.\n * State is indicated by current value of _onByte, all states are named as _collect.\n *\n * STOMP standards https://stomp.github.io/stomp-specification-1.2.html\n * imply that all lengths are considered in bytes (instead of string lengths).\n * So, before actual parsing, if the incoming data is String it is converted to Octets.\n * This allows faithful implementation of the protocol and allows NULL Octets to be present in the body.\n *\n * There is no peek function on the incoming data.\n * When a state change occurs based on an Octet without consuming the Octet,\n * the Octet, after state change, is fed again (_reinjectByte).\n * This became possible as the state change can be determined by inspecting just one Octet.\n *\n * There are two modes to collect the body, if content-length header is there then it by counting Octets\n * otherwise it is determined by NULL terminator.\n *\n * Following the standards, the command and headers are converted to Strings\n * and the body is returned as Octets.\n * Headers are returned as an array and not as Hash - to allow multiple occurrence of an header.\n *\n * This parser does not use Regular Expressions as that can only operate on Strings.\n *\n * It handles if multiple STOMP frames are given as one chunk, a frame is split into multiple chunks, or\n * any combination there of. The parser remembers its state (any partial frame) and continues when a new chunk\n * is pushed.\n *\n * Typically the higher level function will convert headers to Hash, handle unescaping of header values\n * (which is protocol version specific), and convert body to text.\n *\n * Check the parser.spec.js to understand cases that this parser is supposed to handle.\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\n\nexport class Parser {\n  constructor(onFrame, onIncomingPing) {\n    this.onFrame = onFrame;\n    this.onIncomingPing = onIncomingPing;\n    this._encoder = new TextEncoder();\n    this._decoder = new TextDecoder();\n    this._token = [];\n\n    this._initState();\n  }\n\n  parseChunk(segment, appendMissingNULLonIncoming = false) {\n    let chunk;\n\n    if (typeof segment === 'string') {\n      chunk = this._encoder.encode(segment);\n    } else {\n      chunk = new Uint8Array(segment);\n    } // See https://github.com/stomp-js/stompjs/issues/89\n    // Remove when underlying issue is fixed.\n    //\n    // Send a NULL byte, if the last byte of a Text frame was not NULL.F\n\n\n    if (appendMissingNULLonIncoming && chunk[chunk.length - 1] !== 0) {\n      const chunkWithNull = new Uint8Array(chunk.length + 1);\n      chunkWithNull.set(chunk, 0);\n      chunkWithNull[chunk.length] = 0;\n      chunk = chunkWithNull;\n    } // tslint:disable-next-line:prefer-for-of\n\n\n    for (let i = 0; i < chunk.length; i++) {\n      const byte = chunk[i];\n\n      this._onByte(byte);\n    }\n  } // The following implements a simple Rec Descent Parser.\n  // The grammar is simple and just one byte tells what should be the next state\n\n\n  _collectFrame(byte) {\n    if (byte === NULL) {\n      // Ignore\n      return;\n    }\n\n    if (byte === CR) {\n      // Ignore CR\n      return;\n    }\n\n    if (byte === LF) {\n      // Incoming Ping\n      this.onIncomingPing();\n      return;\n    }\n\n    this._onByte = this._collectCommand;\n\n    this._reinjectByte(byte);\n  }\n\n  _collectCommand(byte) {\n    if (byte === CR) {\n      // Ignore CR\n      return;\n    }\n\n    if (byte === LF) {\n      this._results.command = this._consumeTokenAsUTF8();\n      this._onByte = this._collectHeaders;\n      return;\n    }\n\n    this._consumeByte(byte);\n  }\n\n  _collectHeaders(byte) {\n    if (byte === CR) {\n      // Ignore CR\n      return;\n    }\n\n    if (byte === LF) {\n      this._setupCollectBody();\n\n      return;\n    }\n\n    this._onByte = this._collectHeaderKey;\n\n    this._reinjectByte(byte);\n  }\n\n  _reinjectByte(byte) {\n    this._onByte(byte);\n  }\n\n  _collectHeaderKey(byte) {\n    if (byte === COLON) {\n      this._headerKey = this._consumeTokenAsUTF8();\n      this._onByte = this._collectHeaderValue;\n      return;\n    }\n\n    this._consumeByte(byte);\n  }\n\n  _collectHeaderValue(byte) {\n    if (byte === CR) {\n      // Ignore CR\n      return;\n    }\n\n    if (byte === LF) {\n      this._results.headers.push([this._headerKey, this._consumeTokenAsUTF8()]);\n\n      this._headerKey = undefined;\n      this._onByte = this._collectHeaders;\n      return;\n    }\n\n    this._consumeByte(byte);\n  }\n\n  _setupCollectBody() {\n    const contentLengthHeader = this._results.headers.filter(header => {\n      return header[0] === 'content-length';\n    })[0];\n\n    if (contentLengthHeader) {\n      this._bodyBytesRemaining = parseInt(contentLengthHeader[1], 10);\n      this._onByte = this._collectBodyFixedSize;\n    } else {\n      this._onByte = this._collectBodyNullTerminated;\n    }\n  }\n\n  _collectBodyNullTerminated(byte) {\n    if (byte === NULL) {\n      this._retrievedBody();\n\n      return;\n    }\n\n    this._consumeByte(byte);\n  }\n\n  _collectBodyFixedSize(byte) {\n    // It is post decrement, so that we discard the trailing NULL octet\n    if (this._bodyBytesRemaining-- === 0) {\n      this._retrievedBody();\n\n      return;\n    }\n\n    this._consumeByte(byte);\n  }\n\n  _retrievedBody() {\n    this._results.binaryBody = this._consumeTokenAsRaw();\n\n    try {\n      this.onFrame(this._results);\n    } catch (e) {\n      console.log(`Ignoring an exception thrown by a frame handler. Original exception: `, e);\n    }\n\n    this._initState();\n  } // Rec Descent Parser helpers\n\n\n  _consumeByte(byte) {\n    this._token.push(byte);\n  }\n\n  _consumeTokenAsUTF8() {\n    return this._decoder.decode(this._consumeTokenAsRaw());\n  }\n\n  _consumeTokenAsRaw() {\n    const rawResult = new Uint8Array(this._token);\n    this._token = [];\n    return rawResult;\n  }\n\n  _initState() {\n    this._results = {\n      command: undefined,\n      headers: [],\n      binaryBody: undefined\n    };\n    this._token = [];\n    this._headerKey = undefined;\n    this._onByte = this._collectFrame;\n  }\n\n}","map":{"version":3,"names":["NULL","LF","CR","COLON","Parser","constructor","onFrame","onIncomingPing","_encoder","TextEncoder","_decoder","TextDecoder","_token","_initState","parseChunk","segment","appendMissingNULLonIncoming","chunk","encode","Uint8Array","length","chunkWithNull","set","i","byte","_onByte","_collectFrame","_collectCommand","_reinjectByte","_results","command","_consumeTokenAsUTF8","_collectHeaders","_consumeByte","_setupCollectBody","_collectHeaderKey","_headerKey","_collectHeaderValue","headers","push","undefined","contentLengthHeader","filter","header","_bodyBytesRemaining","parseInt","_collectBodyFixedSize","_collectBodyNullTerminated","_retrievedBody","binaryBody","_consumeTokenAsRaw","e","console","log","decode","rawResult"],"sources":["C:/Users/Admins/Desktop/New folder/test-app/node_modules/@stomp/stompjs/esm6/parser.js"],"sourcesContent":["/**\n * @internal\n */\nconst NULL = 0;\n/**\n * @internal\n */\nconst LF = 10;\n/**\n * @internal\n */\nconst CR = 13;\n/**\n * @internal\n */\nconst COLON = 58;\n/**\n * This is an evented, rec descent parser.\n * A stream of Octets can be passed and whenever it recognizes\n * a complete Frame or an incoming ping it will invoke the registered callbacks.\n *\n * All incoming Octets are fed into _onByte function.\n * Depending on current state the _onByte function keeps changing.\n * Depending on the state it keeps accumulating into _token and _results.\n * State is indicated by current value of _onByte, all states are named as _collect.\n *\n * STOMP standards https://stomp.github.io/stomp-specification-1.2.html\n * imply that all lengths are considered in bytes (instead of string lengths).\n * So, before actual parsing, if the incoming data is String it is converted to Octets.\n * This allows faithful implementation of the protocol and allows NULL Octets to be present in the body.\n *\n * There is no peek function on the incoming data.\n * When a state change occurs based on an Octet without consuming the Octet,\n * the Octet, after state change, is fed again (_reinjectByte).\n * This became possible as the state change can be determined by inspecting just one Octet.\n *\n * There are two modes to collect the body, if content-length header is there then it by counting Octets\n * otherwise it is determined by NULL terminator.\n *\n * Following the standards, the command and headers are converted to Strings\n * and the body is returned as Octets.\n * Headers are returned as an array and not as Hash - to allow multiple occurrence of an header.\n *\n * This parser does not use Regular Expressions as that can only operate on Strings.\n *\n * It handles if multiple STOMP frames are given as one chunk, a frame is split into multiple chunks, or\n * any combination there of. The parser remembers its state (any partial frame) and continues when a new chunk\n * is pushed.\n *\n * Typically the higher level function will convert headers to Hash, handle unescaping of header values\n * (which is protocol version specific), and convert body to text.\n *\n * Check the parser.spec.js to understand cases that this parser is supposed to handle.\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\nexport class Parser {\n    constructor(onFrame, onIncomingPing) {\n        this.onFrame = onFrame;\n        this.onIncomingPing = onIncomingPing;\n        this._encoder = new TextEncoder();\n        this._decoder = new TextDecoder();\n        this._token = [];\n        this._initState();\n    }\n    parseChunk(segment, appendMissingNULLonIncoming = false) {\n        let chunk;\n        if (typeof segment === 'string') {\n            chunk = this._encoder.encode(segment);\n        }\n        else {\n            chunk = new Uint8Array(segment);\n        }\n        // See https://github.com/stomp-js/stompjs/issues/89\n        // Remove when underlying issue is fixed.\n        //\n        // Send a NULL byte, if the last byte of a Text frame was not NULL.F\n        if (appendMissingNULLonIncoming && chunk[chunk.length - 1] !== 0) {\n            const chunkWithNull = new Uint8Array(chunk.length + 1);\n            chunkWithNull.set(chunk, 0);\n            chunkWithNull[chunk.length] = 0;\n            chunk = chunkWithNull;\n        }\n        // tslint:disable-next-line:prefer-for-of\n        for (let i = 0; i < chunk.length; i++) {\n            const byte = chunk[i];\n            this._onByte(byte);\n        }\n    }\n    // The following implements a simple Rec Descent Parser.\n    // The grammar is simple and just one byte tells what should be the next state\n    _collectFrame(byte) {\n        if (byte === NULL) {\n            // Ignore\n            return;\n        }\n        if (byte === CR) {\n            // Ignore CR\n            return;\n        }\n        if (byte === LF) {\n            // Incoming Ping\n            this.onIncomingPing();\n            return;\n        }\n        this._onByte = this._collectCommand;\n        this._reinjectByte(byte);\n    }\n    _collectCommand(byte) {\n        if (byte === CR) {\n            // Ignore CR\n            return;\n        }\n        if (byte === LF) {\n            this._results.command = this._consumeTokenAsUTF8();\n            this._onByte = this._collectHeaders;\n            return;\n        }\n        this._consumeByte(byte);\n    }\n    _collectHeaders(byte) {\n        if (byte === CR) {\n            // Ignore CR\n            return;\n        }\n        if (byte === LF) {\n            this._setupCollectBody();\n            return;\n        }\n        this._onByte = this._collectHeaderKey;\n        this._reinjectByte(byte);\n    }\n    _reinjectByte(byte) {\n        this._onByte(byte);\n    }\n    _collectHeaderKey(byte) {\n        if (byte === COLON) {\n            this._headerKey = this._consumeTokenAsUTF8();\n            this._onByte = this._collectHeaderValue;\n            return;\n        }\n        this._consumeByte(byte);\n    }\n    _collectHeaderValue(byte) {\n        if (byte === CR) {\n            // Ignore CR\n            return;\n        }\n        if (byte === LF) {\n            this._results.headers.push([\n                this._headerKey,\n                this._consumeTokenAsUTF8(),\n            ]);\n            this._headerKey = undefined;\n            this._onByte = this._collectHeaders;\n            return;\n        }\n        this._consumeByte(byte);\n    }\n    _setupCollectBody() {\n        const contentLengthHeader = this._results.headers.filter((header) => {\n            return header[0] === 'content-length';\n        })[0];\n        if (contentLengthHeader) {\n            this._bodyBytesRemaining = parseInt(contentLengthHeader[1], 10);\n            this._onByte = this._collectBodyFixedSize;\n        }\n        else {\n            this._onByte = this._collectBodyNullTerminated;\n        }\n    }\n    _collectBodyNullTerminated(byte) {\n        if (byte === NULL) {\n            this._retrievedBody();\n            return;\n        }\n        this._consumeByte(byte);\n    }\n    _collectBodyFixedSize(byte) {\n        // It is post decrement, so that we discard the trailing NULL octet\n        if (this._bodyBytesRemaining-- === 0) {\n            this._retrievedBody();\n            return;\n        }\n        this._consumeByte(byte);\n    }\n    _retrievedBody() {\n        this._results.binaryBody = this._consumeTokenAsRaw();\n        try {\n            this.onFrame(this._results);\n        }\n        catch (e) {\n            console.log(`Ignoring an exception thrown by a frame handler. Original exception: `, e);\n        }\n        this._initState();\n    }\n    // Rec Descent Parser helpers\n    _consumeByte(byte) {\n        this._token.push(byte);\n    }\n    _consumeTokenAsUTF8() {\n        return this._decoder.decode(this._consumeTokenAsRaw());\n    }\n    _consumeTokenAsRaw() {\n        const rawResult = new Uint8Array(this._token);\n        this._token = [];\n        return rawResult;\n    }\n    _initState() {\n        this._results = {\n            command: undefined,\n            headers: [],\n            binaryBody: undefined,\n        };\n        this._token = [];\n        this._headerKey = undefined;\n        this._onByte = this._collectFrame;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}