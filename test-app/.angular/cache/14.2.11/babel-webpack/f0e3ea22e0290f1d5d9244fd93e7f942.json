{"ast":null,"code":"import { BYTE } from './byte.js';\nimport { FrameImpl } from './frame-impl.js';\nimport { Parser } from './parser.js';\nimport { StompSocketState } from './types.js';\nimport { Versions } from './versions.js';\nimport { augmentWebsocket } from './augment-websocket.js';\n/**\n * The STOMP protocol handler\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\n\nexport class StompHandler {\n  constructor(_client, _webSocket, config) {\n    this._client = _client;\n    this._webSocket = _webSocket;\n    this._connected = false;\n    this._serverFrameHandlers = {\n      // [CONNECTED Frame](https://stomp.github.com/stomp-specification-1.2.html#CONNECTED_Frame)\n      CONNECTED: frame => {\n        this.debug(`connected to server ${frame.headers.server}`);\n        this._connected = true;\n        this._connectedVersion = frame.headers.version; // STOMP version 1.2 needs header values to be escaped\n\n        if (this._connectedVersion === Versions.V1_2) {\n          this._escapeHeaderValues = true;\n        }\n\n        this._setupHeartbeat(frame.headers);\n\n        this.onConnect(frame);\n      },\n      // [MESSAGE Frame](https://stomp.github.com/stomp-specification-1.2.html#MESSAGE)\n      MESSAGE: frame => {\n        // the callback is registered when the client calls\n        // `subscribe()`.\n        // If there is no registered subscription for the received message,\n        // the default `onUnhandledMessage` callback is used that the client can set.\n        // This is useful for subscriptions that are automatically created\n        // on the browser side (e.g. [RabbitMQ's temporary\n        // queues](https://www.rabbitmq.com/stomp.html)).\n        const subscription = frame.headers.subscription;\n        const onReceive = this._subscriptions[subscription] || this.onUnhandledMessage; // bless the frame to be a Message\n\n        const message = frame;\n        const client = this;\n        const messageId = this._connectedVersion === Versions.V1_2 ? message.headers.ack : message.headers['message-id']; // add `ack()` and `nack()` methods directly to the returned frame\n        // so that a simple call to `message.ack()` can acknowledge the message.\n\n        message.ack = (headers = {}) => {\n          return client.ack(messageId, subscription, headers);\n        };\n\n        message.nack = (headers = {}) => {\n          return client.nack(messageId, subscription, headers);\n        };\n\n        onReceive(message);\n      },\n      // [RECEIPT Frame](https://stomp.github.com/stomp-specification-1.2.html#RECEIPT)\n      RECEIPT: frame => {\n        const callback = this._receiptWatchers[frame.headers['receipt-id']];\n\n        if (callback) {\n          callback(frame); // Server will acknowledge only once, remove the callback\n\n          delete this._receiptWatchers[frame.headers['receipt-id']];\n        } else {\n          this.onUnhandledReceipt(frame);\n        }\n      },\n      // [ERROR Frame](https://stomp.github.com/stomp-specification-1.2.html#ERROR)\n      ERROR: frame => {\n        this.onStompError(frame);\n      }\n    }; // used to index subscribers\n\n    this._counter = 0; // subscription callbacks indexed by subscriber's ID\n\n    this._subscriptions = {}; // receipt-watchers indexed by receipts-ids\n\n    this._receiptWatchers = {};\n    this._partialData = '';\n    this._escapeHeaderValues = false;\n    this._lastServerActivityTS = Date.now();\n    this.debug = config.debug;\n    this.stompVersions = config.stompVersions;\n    this.connectHeaders = config.connectHeaders;\n    this.disconnectHeaders = config.disconnectHeaders;\n    this.heartbeatIncoming = config.heartbeatIncoming;\n    this.heartbeatOutgoing = config.heartbeatOutgoing;\n    this.splitLargeFrames = config.splitLargeFrames;\n    this.maxWebSocketChunkSize = config.maxWebSocketChunkSize;\n    this.forceBinaryWSFrames = config.forceBinaryWSFrames;\n    this.logRawCommunication = config.logRawCommunication;\n    this.appendMissingNULLonIncoming = config.appendMissingNULLonIncoming;\n    this.discardWebsocketOnCommFailure = config.discardWebsocketOnCommFailure;\n    this.onConnect = config.onConnect;\n    this.onDisconnect = config.onDisconnect;\n    this.onStompError = config.onStompError;\n    this.onWebSocketClose = config.onWebSocketClose;\n    this.onWebSocketError = config.onWebSocketError;\n    this.onUnhandledMessage = config.onUnhandledMessage;\n    this.onUnhandledReceipt = config.onUnhandledReceipt;\n    this.onUnhandledFrame = config.onUnhandledFrame;\n  }\n\n  get connectedVersion() {\n    return this._connectedVersion;\n  }\n\n  get connected() {\n    return this._connected;\n  }\n\n  start() {\n    const parser = new Parser( // On Frame\n    rawFrame => {\n      const frame = FrameImpl.fromRawFrame(rawFrame, this._escapeHeaderValues); // if this.logRawCommunication is set, the rawChunk is logged at this._webSocket.onmessage\n\n      if (!this.logRawCommunication) {\n        this.debug(`<<< ${frame}`);\n      }\n\n      const serverFrameHandler = this._serverFrameHandlers[frame.command] || this.onUnhandledFrame;\n      serverFrameHandler(frame);\n    }, // On Incoming Ping\n    () => {\n      this.debug('<<< PONG');\n    });\n\n    this._webSocket.onmessage = evt => {\n      this.debug('Received data');\n      this._lastServerActivityTS = Date.now();\n\n      if (this.logRawCommunication) {\n        const rawChunkAsString = evt.data instanceof ArrayBuffer ? new TextDecoder().decode(evt.data) : evt.data;\n        this.debug(`<<< ${rawChunkAsString}`);\n      }\n\n      parser.parseChunk(evt.data, this.appendMissingNULLonIncoming);\n    };\n\n    this._webSocket.onclose = closeEvent => {\n      this.debug(`Connection closed to ${this._webSocket.url}`);\n\n      this._cleanUp();\n\n      this.onWebSocketClose(closeEvent);\n    };\n\n    this._webSocket.onerror = errorEvent => {\n      this.onWebSocketError(errorEvent);\n    };\n\n    this._webSocket.onopen = () => {\n      // Clone before updating\n      const connectHeaders = Object.assign({}, this.connectHeaders);\n      this.debug('Web Socket Opened...');\n      connectHeaders['accept-version'] = this.stompVersions.supportedVersions();\n      connectHeaders['heart-beat'] = [this.heartbeatOutgoing, this.heartbeatIncoming].join(',');\n\n      this._transmit({\n        command: 'CONNECT',\n        headers: connectHeaders\n      });\n    };\n  }\n\n  _setupHeartbeat(headers) {\n    if (headers.version !== Versions.V1_1 && headers.version !== Versions.V1_2) {\n      return;\n    } // It is valid for the server to not send this header\n    // https://stomp.github.io/stomp-specification-1.2.html#Heart-beating\n\n\n    if (!headers['heart-beat']) {\n      return;\n    } // heart-beat header received from the server looks like:\n    //\n    //     heart-beat: sx, sy\n\n\n    const [serverOutgoing, serverIncoming] = headers['heart-beat'].split(',').map(v => parseInt(v, 10));\n\n    if (this.heartbeatOutgoing !== 0 && serverIncoming !== 0) {\n      const ttl = Math.max(this.heartbeatOutgoing, serverIncoming);\n      this.debug(`send PING every ${ttl}ms`);\n      this._pinger = setInterval(() => {\n        if (this._webSocket.readyState === StompSocketState.OPEN) {\n          this._webSocket.send(BYTE.LF);\n\n          this.debug('>>> PING');\n        }\n      }, ttl);\n    }\n\n    if (this.heartbeatIncoming !== 0 && serverOutgoing !== 0) {\n      const ttl = Math.max(this.heartbeatIncoming, serverOutgoing);\n      this.debug(`check PONG every ${ttl}ms`);\n      this._ponger = setInterval(() => {\n        const delta = Date.now() - this._lastServerActivityTS; // We wait twice the TTL to be flexible on window's setInterval calls\n\n\n        if (delta > ttl * 2) {\n          this.debug(`did not receive server activity for the last ${delta}ms`);\n\n          this._closeOrDiscardWebsocket();\n        }\n      }, ttl);\n    }\n  }\n\n  _closeOrDiscardWebsocket() {\n    if (this.discardWebsocketOnCommFailure) {\n      this.debug('Discarding websocket, the underlying socket may linger for a while');\n      this.discardWebsocket();\n    } else {\n      this.debug('Issuing close on the websocket');\n\n      this._closeWebsocket();\n    }\n  }\n\n  forceDisconnect() {\n    if (this._webSocket) {\n      if (this._webSocket.readyState === StompSocketState.CONNECTING || this._webSocket.readyState === StompSocketState.OPEN) {\n        this._closeOrDiscardWebsocket();\n      }\n    }\n  }\n\n  _closeWebsocket() {\n    this._webSocket.onmessage = () => {}; // ignore messages\n\n\n    this._webSocket.close();\n  }\n\n  discardWebsocket() {\n    if (typeof this._webSocket.terminate !== 'function') {\n      augmentWebsocket(this._webSocket, msg => this.debug(msg));\n    } // @ts-ignore - this method will be there at this stage\n\n\n    this._webSocket.terminate();\n  }\n\n  _transmit(params) {\n    const {\n      command,\n      headers,\n      body,\n      binaryBody,\n      skipContentLengthHeader\n    } = params;\n    const frame = new FrameImpl({\n      command,\n      headers,\n      body,\n      binaryBody,\n      escapeHeaderValues: this._escapeHeaderValues,\n      skipContentLengthHeader\n    });\n    let rawChunk = frame.serialize();\n\n    if (this.logRawCommunication) {\n      this.debug(`>>> ${rawChunk}`);\n    } else {\n      this.debug(`>>> ${frame}`);\n    }\n\n    if (this.forceBinaryWSFrames && typeof rawChunk === 'string') {\n      rawChunk = new TextEncoder().encode(rawChunk);\n    }\n\n    if (typeof rawChunk !== 'string' || !this.splitLargeFrames) {\n      this._webSocket.send(rawChunk);\n    } else {\n      let out = rawChunk;\n\n      while (out.length > 0) {\n        const chunk = out.substring(0, this.maxWebSocketChunkSize);\n        out = out.substring(this.maxWebSocketChunkSize);\n\n        this._webSocket.send(chunk);\n\n        this.debug(`chunk sent = ${chunk.length}, remaining = ${out.length}`);\n      }\n    }\n  }\n\n  dispose() {\n    if (this.connected) {\n      try {\n        // clone before updating\n        const disconnectHeaders = Object.assign({}, this.disconnectHeaders);\n\n        if (!disconnectHeaders.receipt) {\n          disconnectHeaders.receipt = `close-${this._counter++}`;\n        }\n\n        this.watchForReceipt(disconnectHeaders.receipt, frame => {\n          this._closeWebsocket();\n\n          this._cleanUp();\n\n          this.onDisconnect(frame);\n        });\n\n        this._transmit({\n          command: 'DISCONNECT',\n          headers: disconnectHeaders\n        });\n      } catch (error) {\n        this.debug(`Ignoring error during disconnect ${error}`);\n      }\n    } else {\n      if (this._webSocket.readyState === StompSocketState.CONNECTING || this._webSocket.readyState === StompSocketState.OPEN) {\n        this._closeWebsocket();\n      }\n    }\n  }\n\n  _cleanUp() {\n    this._connected = false;\n\n    if (this._pinger) {\n      clearInterval(this._pinger);\n      this._pinger = undefined;\n    }\n\n    if (this._ponger) {\n      clearInterval(this._ponger);\n      this._ponger = undefined;\n    }\n  }\n\n  publish(params) {\n    const {\n      destination,\n      headers,\n      body,\n      binaryBody,\n      skipContentLengthHeader\n    } = params;\n    const hdrs = Object.assign({\n      destination\n    }, headers);\n\n    this._transmit({\n      command: 'SEND',\n      headers: hdrs,\n      body,\n      binaryBody,\n      skipContentLengthHeader\n    });\n  }\n\n  watchForReceipt(receiptId, callback) {\n    this._receiptWatchers[receiptId] = callback;\n  }\n\n  subscribe(destination, callback, headers = {}) {\n    headers = Object.assign({}, headers);\n\n    if (!headers.id) {\n      headers.id = `sub-${this._counter++}`;\n    }\n\n    headers.destination = destination;\n    this._subscriptions[headers.id] = callback;\n\n    this._transmit({\n      command: 'SUBSCRIBE',\n      headers\n    });\n\n    const client = this;\n    return {\n      id: headers.id,\n\n      unsubscribe(hdrs) {\n        return client.unsubscribe(headers.id, hdrs);\n      }\n\n    };\n  }\n\n  unsubscribe(id, headers = {}) {\n    headers = Object.assign({}, headers);\n    delete this._subscriptions[id];\n    headers.id = id;\n\n    this._transmit({\n      command: 'UNSUBSCRIBE',\n      headers\n    });\n  }\n\n  begin(transactionId) {\n    const txId = transactionId || `tx-${this._counter++}`;\n\n    this._transmit({\n      command: 'BEGIN',\n      headers: {\n        transaction: txId\n      }\n    });\n\n    const client = this;\n    return {\n      id: txId,\n\n      commit() {\n        client.commit(txId);\n      },\n\n      abort() {\n        client.abort(txId);\n      }\n\n    };\n  }\n\n  commit(transactionId) {\n    this._transmit({\n      command: 'COMMIT',\n      headers: {\n        transaction: transactionId\n      }\n    });\n  }\n\n  abort(transactionId) {\n    this._transmit({\n      command: 'ABORT',\n      headers: {\n        transaction: transactionId\n      }\n    });\n  }\n\n  ack(messageId, subscriptionId, headers = {}) {\n    headers = Object.assign({}, headers);\n\n    if (this._connectedVersion === Versions.V1_2) {\n      headers.id = messageId;\n    } else {\n      headers['message-id'] = messageId;\n    }\n\n    headers.subscription = subscriptionId;\n\n    this._transmit({\n      command: 'ACK',\n      headers\n    });\n  }\n\n  nack(messageId, subscriptionId, headers = {}) {\n    headers = Object.assign({}, headers);\n\n    if (this._connectedVersion === Versions.V1_2) {\n      headers.id = messageId;\n    } else {\n      headers['message-id'] = messageId;\n    }\n\n    headers.subscription = subscriptionId;\n    return this._transmit({\n      command: 'NACK',\n      headers\n    });\n  }\n\n}","map":{"version":3,"names":["BYTE","FrameImpl","Parser","StompSocketState","Versions","augmentWebsocket","StompHandler","constructor","_client","_webSocket","config","_connected","_serverFrameHandlers","CONNECTED","frame","debug","headers","server","_connectedVersion","version","V1_2","_escapeHeaderValues","_setupHeartbeat","onConnect","MESSAGE","subscription","onReceive","_subscriptions","onUnhandledMessage","message","client","messageId","ack","nack","RECEIPT","callback","_receiptWatchers","onUnhandledReceipt","ERROR","onStompError","_counter","_partialData","_lastServerActivityTS","Date","now","stompVersions","connectHeaders","disconnectHeaders","heartbeatIncoming","heartbeatOutgoing","splitLargeFrames","maxWebSocketChunkSize","forceBinaryWSFrames","logRawCommunication","appendMissingNULLonIncoming","discardWebsocketOnCommFailure","onDisconnect","onWebSocketClose","onWebSocketError","onUnhandledFrame","connectedVersion","connected","start","parser","rawFrame","fromRawFrame","serverFrameHandler","command","onmessage","evt","rawChunkAsString","data","ArrayBuffer","TextDecoder","decode","parseChunk","onclose","closeEvent","url","_cleanUp","onerror","errorEvent","onopen","Object","assign","supportedVersions","join","_transmit","V1_1","serverOutgoing","serverIncoming","split","map","v","parseInt","ttl","Math","max","_pinger","setInterval","readyState","OPEN","send","LF","_ponger","delta","_closeOrDiscardWebsocket","discardWebsocket","_closeWebsocket","forceDisconnect","CONNECTING","close","terminate","msg","params","body","binaryBody","skipContentLengthHeader","escapeHeaderValues","rawChunk","serialize","TextEncoder","encode","out","length","chunk","substring","dispose","receipt","watchForReceipt","error","clearInterval","undefined","publish","destination","hdrs","receiptId","subscribe","id","unsubscribe","begin","transactionId","txId","transaction","commit","abort","subscriptionId"],"sources":["C:/Users/Admins/Desktop/New folder/test-app/node_modules/@stomp/stompjs/esm6/stomp-handler.js"],"sourcesContent":["import { BYTE } from './byte.js';\nimport { FrameImpl } from './frame-impl.js';\nimport { Parser } from './parser.js';\nimport { StompSocketState, } from './types.js';\nimport { Versions } from './versions.js';\nimport { augmentWebsocket } from './augment-websocket.js';\n/**\n * The STOMP protocol handler\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\nexport class StompHandler {\n    constructor(_client, _webSocket, config) {\n        this._client = _client;\n        this._webSocket = _webSocket;\n        this._connected = false;\n        this._serverFrameHandlers = {\n            // [CONNECTED Frame](https://stomp.github.com/stomp-specification-1.2.html#CONNECTED_Frame)\n            CONNECTED: frame => {\n                this.debug(`connected to server ${frame.headers.server}`);\n                this._connected = true;\n                this._connectedVersion = frame.headers.version;\n                // STOMP version 1.2 needs header values to be escaped\n                if (this._connectedVersion === Versions.V1_2) {\n                    this._escapeHeaderValues = true;\n                }\n                this._setupHeartbeat(frame.headers);\n                this.onConnect(frame);\n            },\n            // [MESSAGE Frame](https://stomp.github.com/stomp-specification-1.2.html#MESSAGE)\n            MESSAGE: frame => {\n                // the callback is registered when the client calls\n                // `subscribe()`.\n                // If there is no registered subscription for the received message,\n                // the default `onUnhandledMessage` callback is used that the client can set.\n                // This is useful for subscriptions that are automatically created\n                // on the browser side (e.g. [RabbitMQ's temporary\n                // queues](https://www.rabbitmq.com/stomp.html)).\n                const subscription = frame.headers.subscription;\n                const onReceive = this._subscriptions[subscription] || this.onUnhandledMessage;\n                // bless the frame to be a Message\n                const message = frame;\n                const client = this;\n                const messageId = this._connectedVersion === Versions.V1_2\n                    ? message.headers.ack\n                    : message.headers['message-id'];\n                // add `ack()` and `nack()` methods directly to the returned frame\n                // so that a simple call to `message.ack()` can acknowledge the message.\n                message.ack = (headers = {}) => {\n                    return client.ack(messageId, subscription, headers);\n                };\n                message.nack = (headers = {}) => {\n                    return client.nack(messageId, subscription, headers);\n                };\n                onReceive(message);\n            },\n            // [RECEIPT Frame](https://stomp.github.com/stomp-specification-1.2.html#RECEIPT)\n            RECEIPT: frame => {\n                const callback = this._receiptWatchers[frame.headers['receipt-id']];\n                if (callback) {\n                    callback(frame);\n                    // Server will acknowledge only once, remove the callback\n                    delete this._receiptWatchers[frame.headers['receipt-id']];\n                }\n                else {\n                    this.onUnhandledReceipt(frame);\n                }\n            },\n            // [ERROR Frame](https://stomp.github.com/stomp-specification-1.2.html#ERROR)\n            ERROR: frame => {\n                this.onStompError(frame);\n            },\n        };\n        // used to index subscribers\n        this._counter = 0;\n        // subscription callbacks indexed by subscriber's ID\n        this._subscriptions = {};\n        // receipt-watchers indexed by receipts-ids\n        this._receiptWatchers = {};\n        this._partialData = '';\n        this._escapeHeaderValues = false;\n        this._lastServerActivityTS = Date.now();\n        this.debug = config.debug;\n        this.stompVersions = config.stompVersions;\n        this.connectHeaders = config.connectHeaders;\n        this.disconnectHeaders = config.disconnectHeaders;\n        this.heartbeatIncoming = config.heartbeatIncoming;\n        this.heartbeatOutgoing = config.heartbeatOutgoing;\n        this.splitLargeFrames = config.splitLargeFrames;\n        this.maxWebSocketChunkSize = config.maxWebSocketChunkSize;\n        this.forceBinaryWSFrames = config.forceBinaryWSFrames;\n        this.logRawCommunication = config.logRawCommunication;\n        this.appendMissingNULLonIncoming = config.appendMissingNULLonIncoming;\n        this.discardWebsocketOnCommFailure = config.discardWebsocketOnCommFailure;\n        this.onConnect = config.onConnect;\n        this.onDisconnect = config.onDisconnect;\n        this.onStompError = config.onStompError;\n        this.onWebSocketClose = config.onWebSocketClose;\n        this.onWebSocketError = config.onWebSocketError;\n        this.onUnhandledMessage = config.onUnhandledMessage;\n        this.onUnhandledReceipt = config.onUnhandledReceipt;\n        this.onUnhandledFrame = config.onUnhandledFrame;\n    }\n    get connectedVersion() {\n        return this._connectedVersion;\n    }\n    get connected() {\n        return this._connected;\n    }\n    start() {\n        const parser = new Parser(\n        // On Frame\n        rawFrame => {\n            const frame = FrameImpl.fromRawFrame(rawFrame, this._escapeHeaderValues);\n            // if this.logRawCommunication is set, the rawChunk is logged at this._webSocket.onmessage\n            if (!this.logRawCommunication) {\n                this.debug(`<<< ${frame}`);\n            }\n            const serverFrameHandler = this._serverFrameHandlers[frame.command] || this.onUnhandledFrame;\n            serverFrameHandler(frame);\n        }, \n        // On Incoming Ping\n        () => {\n            this.debug('<<< PONG');\n        });\n        this._webSocket.onmessage = (evt) => {\n            this.debug('Received data');\n            this._lastServerActivityTS = Date.now();\n            if (this.logRawCommunication) {\n                const rawChunkAsString = evt.data instanceof ArrayBuffer\n                    ? new TextDecoder().decode(evt.data)\n                    : evt.data;\n                this.debug(`<<< ${rawChunkAsString}`);\n            }\n            parser.parseChunk(evt.data, this.appendMissingNULLonIncoming);\n        };\n        this._webSocket.onclose = (closeEvent) => {\n            this.debug(`Connection closed to ${this._webSocket.url}`);\n            this._cleanUp();\n            this.onWebSocketClose(closeEvent);\n        };\n        this._webSocket.onerror = (errorEvent) => {\n            this.onWebSocketError(errorEvent);\n        };\n        this._webSocket.onopen = () => {\n            // Clone before updating\n            const connectHeaders = Object.assign({}, this.connectHeaders);\n            this.debug('Web Socket Opened...');\n            connectHeaders['accept-version'] = this.stompVersions.supportedVersions();\n            connectHeaders['heart-beat'] = [\n                this.heartbeatOutgoing,\n                this.heartbeatIncoming,\n            ].join(',');\n            this._transmit({ command: 'CONNECT', headers: connectHeaders });\n        };\n    }\n    _setupHeartbeat(headers) {\n        if (headers.version !== Versions.V1_1 &&\n            headers.version !== Versions.V1_2) {\n            return;\n        }\n        // It is valid for the server to not send this header\n        // https://stomp.github.io/stomp-specification-1.2.html#Heart-beating\n        if (!headers['heart-beat']) {\n            return;\n        }\n        // heart-beat header received from the server looks like:\n        //\n        //     heart-beat: sx, sy\n        const [serverOutgoing, serverIncoming] = headers['heart-beat']\n            .split(',')\n            .map((v) => parseInt(v, 10));\n        if (this.heartbeatOutgoing !== 0 && serverIncoming !== 0) {\n            const ttl = Math.max(this.heartbeatOutgoing, serverIncoming);\n            this.debug(`send PING every ${ttl}ms`);\n            this._pinger = setInterval(() => {\n                if (this._webSocket.readyState === StompSocketState.OPEN) {\n                    this._webSocket.send(BYTE.LF);\n                    this.debug('>>> PING');\n                }\n            }, ttl);\n        }\n        if (this.heartbeatIncoming !== 0 && serverOutgoing !== 0) {\n            const ttl = Math.max(this.heartbeatIncoming, serverOutgoing);\n            this.debug(`check PONG every ${ttl}ms`);\n            this._ponger = setInterval(() => {\n                const delta = Date.now() - this._lastServerActivityTS;\n                // We wait twice the TTL to be flexible on window's setInterval calls\n                if (delta > ttl * 2) {\n                    this.debug(`did not receive server activity for the last ${delta}ms`);\n                    this._closeOrDiscardWebsocket();\n                }\n            }, ttl);\n        }\n    }\n    _closeOrDiscardWebsocket() {\n        if (this.discardWebsocketOnCommFailure) {\n            this.debug('Discarding websocket, the underlying socket may linger for a while');\n            this.discardWebsocket();\n        }\n        else {\n            this.debug('Issuing close on the websocket');\n            this._closeWebsocket();\n        }\n    }\n    forceDisconnect() {\n        if (this._webSocket) {\n            if (this._webSocket.readyState === StompSocketState.CONNECTING ||\n                this._webSocket.readyState === StompSocketState.OPEN) {\n                this._closeOrDiscardWebsocket();\n            }\n        }\n    }\n    _closeWebsocket() {\n        this._webSocket.onmessage = () => { }; // ignore messages\n        this._webSocket.close();\n    }\n    discardWebsocket() {\n        if (typeof this._webSocket.terminate !== 'function') {\n            augmentWebsocket(this._webSocket, (msg) => this.debug(msg));\n        }\n        // @ts-ignore - this method will be there at this stage\n        this._webSocket.terminate();\n    }\n    _transmit(params) {\n        const { command, headers, body, binaryBody, skipContentLengthHeader } = params;\n        const frame = new FrameImpl({\n            command,\n            headers,\n            body,\n            binaryBody,\n            escapeHeaderValues: this._escapeHeaderValues,\n            skipContentLengthHeader,\n        });\n        let rawChunk = frame.serialize();\n        if (this.logRawCommunication) {\n            this.debug(`>>> ${rawChunk}`);\n        }\n        else {\n            this.debug(`>>> ${frame}`);\n        }\n        if (this.forceBinaryWSFrames && typeof rawChunk === 'string') {\n            rawChunk = new TextEncoder().encode(rawChunk);\n        }\n        if (typeof rawChunk !== 'string' || !this.splitLargeFrames) {\n            this._webSocket.send(rawChunk);\n        }\n        else {\n            let out = rawChunk;\n            while (out.length > 0) {\n                const chunk = out.substring(0, this.maxWebSocketChunkSize);\n                out = out.substring(this.maxWebSocketChunkSize);\n                this._webSocket.send(chunk);\n                this.debug(`chunk sent = ${chunk.length}, remaining = ${out.length}`);\n            }\n        }\n    }\n    dispose() {\n        if (this.connected) {\n            try {\n                // clone before updating\n                const disconnectHeaders = Object.assign({}, this.disconnectHeaders);\n                if (!disconnectHeaders.receipt) {\n                    disconnectHeaders.receipt = `close-${this._counter++}`;\n                }\n                this.watchForReceipt(disconnectHeaders.receipt, frame => {\n                    this._closeWebsocket();\n                    this._cleanUp();\n                    this.onDisconnect(frame);\n                });\n                this._transmit({ command: 'DISCONNECT', headers: disconnectHeaders });\n            }\n            catch (error) {\n                this.debug(`Ignoring error during disconnect ${error}`);\n            }\n        }\n        else {\n            if (this._webSocket.readyState === StompSocketState.CONNECTING ||\n                this._webSocket.readyState === StompSocketState.OPEN) {\n                this._closeWebsocket();\n            }\n        }\n    }\n    _cleanUp() {\n        this._connected = false;\n        if (this._pinger) {\n            clearInterval(this._pinger);\n            this._pinger = undefined;\n        }\n        if (this._ponger) {\n            clearInterval(this._ponger);\n            this._ponger = undefined;\n        }\n    }\n    publish(params) {\n        const { destination, headers, body, binaryBody, skipContentLengthHeader } = params;\n        const hdrs = Object.assign({ destination }, headers);\n        this._transmit({\n            command: 'SEND',\n            headers: hdrs,\n            body,\n            binaryBody,\n            skipContentLengthHeader,\n        });\n    }\n    watchForReceipt(receiptId, callback) {\n        this._receiptWatchers[receiptId] = callback;\n    }\n    subscribe(destination, callback, headers = {}) {\n        headers = Object.assign({}, headers);\n        if (!headers.id) {\n            headers.id = `sub-${this._counter++}`;\n        }\n        headers.destination = destination;\n        this._subscriptions[headers.id] = callback;\n        this._transmit({ command: 'SUBSCRIBE', headers });\n        const client = this;\n        return {\n            id: headers.id,\n            unsubscribe(hdrs) {\n                return client.unsubscribe(headers.id, hdrs);\n            },\n        };\n    }\n    unsubscribe(id, headers = {}) {\n        headers = Object.assign({}, headers);\n        delete this._subscriptions[id];\n        headers.id = id;\n        this._transmit({ command: 'UNSUBSCRIBE', headers });\n    }\n    begin(transactionId) {\n        const txId = transactionId || `tx-${this._counter++}`;\n        this._transmit({\n            command: 'BEGIN',\n            headers: {\n                transaction: txId,\n            },\n        });\n        const client = this;\n        return {\n            id: txId,\n            commit() {\n                client.commit(txId);\n            },\n            abort() {\n                client.abort(txId);\n            },\n        };\n    }\n    commit(transactionId) {\n        this._transmit({\n            command: 'COMMIT',\n            headers: {\n                transaction: transactionId,\n            },\n        });\n    }\n    abort(transactionId) {\n        this._transmit({\n            command: 'ABORT',\n            headers: {\n                transaction: transactionId,\n            },\n        });\n    }\n    ack(messageId, subscriptionId, headers = {}) {\n        headers = Object.assign({}, headers);\n        if (this._connectedVersion === Versions.V1_2) {\n            headers.id = messageId;\n        }\n        else {\n            headers['message-id'] = messageId;\n        }\n        headers.subscription = subscriptionId;\n        this._transmit({ command: 'ACK', headers });\n    }\n    nack(messageId, subscriptionId, headers = {}) {\n        headers = Object.assign({}, headers);\n        if (this._connectedVersion === Versions.V1_2) {\n            headers.id = messageId;\n        }\n        else {\n            headers['message-id'] = messageId;\n        }\n        headers.subscription = subscriptionId;\n        return this._transmit({ command: 'NACK', headers });\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}